# **Finding Lane Lines on the Road** 
---

The goals of this project are the following:
* Make a pipeline that finds lane lines on the road images
* Implement that pipeline on the road videos


[//]: # (Image References)
[image0]: ./test_images/whiteCarLaneSwitch.jpg "Raw Image" 
[image1]: ./test_images_output/r_image_gray.jpg "Grayscale"
[image2]: ./test_images_output/r_blurred_image.jpg "Blurred Grayscale"
[image3]: ./test_images_output/r_canny_image.jpg "Canny Edges"
[image4]: ./test_images_output/r_masked_image.jpg "Masked Image"
[image5]: ./test_images_output/r_hough_image.jpg "Hough Lines"
[image6]: ./test_images_output/r_no_outliers_image.jpg "Hough Lines with no outliers"
[image7]: ./test_images_output/r_merged_image.jpg "Final Image"
[image8]: ./test_images_output/solidWhiteRight.jpg "solidWhiteRight"
[image9]: ./test_images_output/solidYellowCurve.jpg "solidYellowCurve"
[image10]: ./test_images_output/solidYellowCurve2.jpg "solidYellowCurve2"
[image11]: ./test_images_output/solidYellowLeft.jpg "solidYellowLeft"
[image12]: ./test_images_output/solidWhiteCurve.jpg "solidWhiteCurve"

---

### Reflection

### 1. PipeLine Description

The pipeline acts on a raw image like this:

![alt text][image0]

My pipeline consists of 5 steps. First, I converted the images to grayscale like this: 

![alt text][image1]
 
Then this image is blurred using a Gaussian kernel filter of size 5 in order to reduce the noise content which will be helpful in the next step of Canny Edge Detection. The blurred image looks like this:

![alt text][image2]

The blurred image is then fed to the Canny Edge detection algorithm which looks for gradients in the image above a certain threshold. Below is the output of Canny Edge Detection:

![alt text][image3]

This image is then masked using a polygon to mask everything in the image except the region of interest like this:

![alt text][image4]

Now Hough Transform is applied to obtain parameters of the lines generated by the Canny Edge algorithm. This is how the output of lines from Hough Transform looks like:

![alt text][image5]

Now as we can see some outliers in the picture. To solve this issue, an outlier rejection funtion is introduced which removes lines with slopes outside a given number of standard deviations. Here's the output:

![alt text][image6]

Next, these multiple lines are replaced by one single line using extrapolation function for each lane. The raw data of individual line segments for left and right lanes is separated based on the slope sign. Then the extrapolation function uses the output of reject_outliers function, feeds it to the polyfit function to obtain single line representation. This final image looks like this:

![alt text][image7]

The final outputs of other test images are as follows:

solidWhiteRight

![alt text][image8]

solidYellowCurve

![alt text][image9]

solidYellowCurve2

![alt text][image10]

solidYellowLeft

![alt text][image11]

solidWhiteCurve

![alt text][image12]

### 2. Potential shortcomings of the current pipeline


One shortcoming is that this pipeline fails at the challenge video where lanes are curvy thoroughout the video. Secondly, there are intermittent shadowed areas on the road which are changing the image gradient.

Another shortcoming could be the region of interest masking, which is currently a carefully chosen quadrilateral centered at the bottom of the image but as we can see in the challenge video, the lower end of the image is taken by the car body which hampers the pipeline function. Even if this polygon is adjusted accordingly to fit this challenge video, this still may not work in a new video with a slightly different image orientation.


### 3. Possible improvements in the pipeline

A possible improvement would be to have an algorithm which takes care of masking region of interest intelligently and is robust enough to work in changing light, shadow and weather conditions

Another potential improvement could be to have an algorithm which is capable of detecting continuously curved lanes.

